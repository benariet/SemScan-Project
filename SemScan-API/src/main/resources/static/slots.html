<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#5B4FCF">
    <title>SemScan - Select Slot</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    <link rel="apple-touch-icon" href="/assets/logo.png">
    <link rel="manifest" href="/manifest.json">
    <link rel="stylesheet" href="css/main.css?v=14">
    <link rel="stylesheet" href="css/slots.css">
</head>
<body style="display: none;">
    <!-- Side Menu Overlay -->
    <div class="side-menu-overlay" id="menuOverlay"></div>

    <!-- Side Menu -->
    <div class="side-menu" id="sideMenu">
        <div class="side-menu-header">
            <h3 id="menuUserName">User</h3>
            <p id="menuUserEmail">user@bgu.ac.il</p>
        </div>
        <div class="side-menu-items">
            <a href="settings.html" class="side-menu-item">
                <svg viewBox="0 0 24 24" width="24" height="24"><path d="M19.14,12.94c0.04-0.31,0.06-0.63,0.06-0.94c0-0.31-0.02-0.63-0.06-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.43,0.17-0.47,0.41L9.25,5.35C8.66,5.59,8.12,5.92,7.63,6.29L5.24,5.33c-0.22-0.08-0.47,0-0.59,0.22L2.74,8.87 C2.62,9.08,2.66,9.34,2.86,9.48l2.03,1.58C4.84,11.37,4.8,11.69,4.8,12s0.02,0.63,0.06,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54 c0.05,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.44-0.17,0.47-0.41l0.36-2.54c0.59-0.24,1.13-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.07-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z"/></svg>
                <span>Settings</span>
            </a>
            <div class="side-menu-divider"></div>
            <a href="#" class="side-menu-item" id="logoutMenuItem">
                <svg viewBox="0 0 24 24" width="24" height="24"><path d="M17 7l-1.41 1.41L18.17 11H8v2h10.17l-2.58 2.58L17 17l5-5zM4 5h8V3H4c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h8v-2H4V5z"/></svg>
                <span>Logout</span>
            </a>
        </div>
    </div>

    <!-- Header -->
    <header class="header header-with-nav">
        <button class="back-btn" onclick="history.back()">
            <svg viewBox="0 0 24 24"><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/></svg>
        </button>
        <h1 class="header-title">Select Slot</h1>
        <div style="display: flex; align-items: center; gap: 4px;">
            <button class="header-refresh-btn" id="refreshBtn" onclick="loadSlots()">
                <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor">
                    <path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/>
                </svg>
            </button>
            <button class="menu-btn" id="menuBtn">
                <svg viewBox="0 0 24 24"><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>
            </button>
        </div>
    </header>

    <div class="container">

        <!-- Slots list -->
        <div class="slots-list" id="slotsList">
            <!-- Slots will be loaded here -->
        </div>

        <!-- Empty state -->
        <div class="no-slots hidden" id="emptyState">
            <div class="no-slots-icon">ðŸ“…</div>
            <h3 class="no-slots-title">No Slots Available</h3>
            <p class="no-slots-text">Check back later for available presentation slots.</p>
        </div>
    </div>

    <!-- Loading overlay -->
    <div class="loading-overlay hidden" id="loadingOverlay">
        <div class="spinner"></div>
    </div>

    <!-- Toast container -->
    <div class="toast-container"></div>

    <script src="js/config.js"></script>
    <script src="js/utils.js"></script>
    <script src="js/api.js"></script>
    <script>
        // Require authentication FIRST - block page until verified
        if (!Utils.isLoggedIn()) {
            window.location.replace('index.html');
            throw new Error('Not authenticated');
        }

        // Show page only after auth verified
        document.body.style.display = '';

        const username = Utils.getUsername();
        let allSlots = [];
        let presenterData = null; // Store fresh API data to use instead of localStorage

        // Setup side menu
        function setupMenu() {
            const menuBtn = document.getElementById('menuBtn');
            const menuOverlay = document.getElementById('menuOverlay');
            const sideMenu = document.getElementById('sideMenu');
            const logoutMenuItem = document.getElementById('logoutMenuItem');

            // Populate user info
            document.getElementById('menuUserName').textContent = username;
            document.getElementById('menuUserEmail').textContent = username + '@bgu.ac.il';

            menuBtn.addEventListener('click', () => {
                sideMenu.classList.add('open');
                menuOverlay.classList.add('open');
            });

            menuOverlay.addEventListener('click', () => {
                sideMenu.classList.remove('open');
                menuOverlay.classList.remove('open');
            });

            logoutMenuItem.addEventListener('click', (e) => {
                e.preventDefault();
                localStorage.clear();
                window.location.href = 'index.html';
            });
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            setupMenu();
            loadSlots();
        });

        async function loadSlots() {
            Utils.showLoading();
            try {
                const response = await API.getPresenterHome(username);
                // API returns: { presenter, slotCatalog, mySlot, myWaitingListSlot }
                allSlots = response.slotCatalog || [];
                presenterData = response.presenter; // Store for later use

                // Update localStorage with fresh presenter data from API
                // This ensures supervisor info is always up-to-date
                if (response.presenter) {
                    const existingData = Utils.getUserData() || {};
                    const updatedData = {
                        ...existingData,
                        firstName: response.presenter.firstName || response.presenter.name?.split(' ')[0] || existingData.firstName,
                        lastName: response.presenter.lastName || response.presenter.name?.split(' ').slice(1).join(' ') || existingData.lastName,
                        supervisorName: response.presenter.supervisorName,
                        supervisorEmail: response.presenter.supervisorEmail,
                        topic: response.presenter.topic,
                        seminarAbstract: response.presenter.seminarAbstract,
                        degree: response.presenter.degree
                    };
                    localStorage.setItem(CONFIG.USER_DATA_KEY, JSON.stringify(updatedData));
                }

                renderSlots();
            } catch (error) {
                Utils.showToast('Failed to load slots: ' + error.message, 'error');
            } finally {
                Utils.hideLoading();
            }
        }

        function renderSlots() {
            const container = document.getElementById('slotsList');
            const emptyState = document.getElementById('emptyState');

            if (allSlots.length === 0) {
                container.innerHTML = '';
                emptyState.classList.remove('hidden');
                return;
            }

            emptyState.classList.add('hidden');
            container.innerHTML = allSlots.map(slot => renderSlotCard(slot)).join('');

            // Attach event listeners
            container.querySelectorAll('[data-action]').forEach(btn => {
                btn.addEventListener('click', handleSlotAction);
            });
        }

        function renderSlotCard(slot) {
            // Determine slot status class - ONLY approved counts for fullness (matches mobile)
            // Green = 0 approved, Yellow = has presenters but not full, Red = approved >= capacity
            const approvedCount = slot.approvedCount || 0;
            const pendingCount = slot.pendingCount || 0;
            const capacity = slot.capacity || 3;
            const isFull = approvedCount >= capacity;
            const hasAnyPresenters = approvedCount > 0 || pendingCount > 0;

            let statusClass = 'slot-available';
            if (isFull) {
                statusClass = 'slot-full';
            } else if (hasAnyPresenters) {
                statusClass = 'slot-semi';
            }

            // Status text - show available spots (Math.max prevents negative from race conditions)
            const availableCount = Math.max(0, slot.availableCount !== undefined ? slot.availableCount : (capacity - approvedCount - pendingCount));
            const statusText = isFull ? 'Full' : `${availableCount}/${capacity} Available`;

            // Date and time (matches mobile format: "Tuesday â€¢ 27/01/2026")
            const dateStr = slot.dayOfWeek + ' â€¢ ' + slot.date;
            const timeStr = slot.timeRange || '';
            const location = slot.building && slot.room ? `Building ${slot.building}, Room ${slot.room}` : 'TBA';

            // User's registration actions
            let actionsHtml = '';

            // Check if user is registered in this slot (matches mobile logic)
            const isUserRegisteredInThisSlot = slot.alreadyRegistered ||
                slot.approvalStatus === 'APPROVED' ||
                slot.approvalStatus === 'PENDING_APPROVAL';

            if (isUserRegisteredInThisSlot) {
                // User has a registration for this slot - check if can cancel
                // COPY FROM ANDROID: canCancel is false if session already completed
                if (slot.canCancel === false) {
                    // Cannot cancel - show disabled message
                    const reason = slot.cancelBlockedReason || 'Cannot cancel after presenting';
                    actionsHtml = `
                        <div class="slot-status-message">${Utils.escapeHtml(reason)}</div>
                    `;
                } else {
                    // Can cancel - show cancel button
                    actionsHtml = `
                        <button class="btn btn-cancel" data-action="cancel" data-slot-id="${slot.slotId}">
                            CANCEL REGISTRATION
                        </button>
                    `;
                }
            } else if (slot.approvalStatus === 'DECLINED' || slot.approvalStatus === 'EXPIRED') {
                // User's previous registration was declined/expired - can register again
                actionsHtml = `
                    <button class="btn btn-register" data-action="register" data-slot-id="${slot.slotId}">
                        Register Again
                    </button>
                `;
            } else if (slot.onWaitingList) {
                // User is on waiting list - show action only, no status box
                actionsHtml = `
                    <button class="btn btn-cancel" data-action="leave-waiting" data-slot-id="${slot.slotId}">
                        Leave Waiting List
                    </button>
                `;
            } else if (slot.state === 'FULL') {
                // Check if waiting list is full (limit is 3 from config)
                // COPY FROM ANDROID: PresenterSlotsAdapter checks isWaitingListFull
                const waitingListLimit = 3; // TODO: get from config if available
                const isWaitingListFull = (slot.waitingListCount || 0) >= waitingListLimit;

                if (!isWaitingListFull) {
                    actionsHtml = `
                        <button class="btn btn-waiting" data-action="join-waiting" data-slot-id="${slot.slotId}">
                            Join Waiting List
                        </button>
                    `;
                } else {
                    // Waiting list is also full - show message
                    actionsHtml = `
                        <div class="slot-status-message">Waiting list is also full</div>
                    `;
                }
            } else if (slot.canRegister) {
                actionsHtml = `
                    <button class="btn btn-register" data-action="register" data-slot-id="${slot.slotId}">
                        Register
                    </button>
                `;
            } else if (slot.disableReason) {
                // Don't show status box for disable reason
            }

            // Build presenter sections as plain text (matches mobile layout)
            // Mobile format: "Approved:\n    PhD, Name (me)"
            let presentersHtml = '';

            // Approved presenters - plain text (escape user data to prevent XSS)
            const approvedPresenters = slot.registered || [];
            if (approvedPresenters.length > 0) {
                const names = approvedPresenters.map(p => {
                    const name = Utils.escapeHtml(p.name || 'Unknown');
                    const degree = Utils.escapeHtml(p.degree || '');
                    const isMe = p.username && p.username.toLowerCase() === username.toLowerCase();
                    const displayName = isMe ? `${name} (me)` : name;
                    return degree ? `${degree}, ${displayName}` : displayName;
                });
                presentersHtml += `<div class="slot-presenters-plain">
                    <div class="presenters-label">Approved:</div>
                    ${names.map(n => `<div class="presenter-line">${n}</div>`).join('')}
                </div>`;
            }

            // Pending presenters - plain text (escape user data to prevent XSS)
            const pendingPresenters = slot.pendingPresenters || [];
            if (pendingPresenters.length > 0) {
                const names = pendingPresenters.map(p => {
                    const name = Utils.escapeHtml(p.name || 'Unknown');
                    const degree = Utils.escapeHtml(p.degree || '');
                    const isMe = p.username && p.username.toLowerCase() === username.toLowerCase();
                    const displayName = isMe ? `${name} (me)` : name;
                    return degree ? `${degree}, ${displayName}` : displayName;
                });
                presentersHtml += `<div class="slot-presenters-plain">
                    <div class="presenters-label">Pending:</div>
                    ${names.map(n => `<div class="presenter-line">${n}</div>`).join('')}
                </div>`;
            }

            // Waiting list - plain text with priorities (escape user data to prevent XSS)
            const waitingListEntries = slot.waitingListEntries || [];
            let waitingListHtml = '';
            if (waitingListEntries.length > 0) {
                const names = waitingListEntries.map((p, idx) => {
                    const name = Utils.escapeHtml(p.name || 'Unknown');
                    const degree = Utils.escapeHtml(p.degree || '');
                    const isMe = p.username && p.username.toLowerCase() === username.toLowerCase();
                    const displayName = isMe ? `${name} (me)` : name;
                    const degreePrefix = degree ? `${degree}, ` : '';
                    return `#${idx + 1} - ${degreePrefix}${displayName}`;
                });
                waitingListHtml = `<div class="slot-presenters-plain">
                    <div class="presenters-label">Waiting List Priorities:</div>
                    ${names.map(n => `<div class="presenter-line">${n}</div>`).join('')}
                </div>`;
            }

            // Combine all (pendingHtml is now part of presentersHtml)
            let pendingHtml = '';

            // Warning message (escape to prevent XSS)
            let warningHtml = '';
            if (slot.warningMessage) {
                warningHtml = `<div class="slot-warning">${Utils.escapeHtml(slot.warningMessage)}</div>`;
            }

            return `
                <div class="slot-card ${statusClass}" data-slot-id="${slot.slotId || slot.id}">
                    <div class="slot-header">
                        <div class="slot-info">
                            <div class="slot-date">${dateStr}</div>
                            <div class="slot-time">${timeStr}</div>
                        </div>
                        <span class="slot-badge">${statusText}</span>
                    </div>
                    <div class="slot-details">
                        <div class="slot-location">
                            <svg viewBox="0 0 24 24">
                                <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/>
                            </svg>
                            <span>${location}</span>
                        </div>
                    </div>
                    ${presentersHtml}
                    ${pendingHtml}
                    ${waitingListHtml}
                    ${warningHtml}
                    ${actionsHtml ? `<div class="slot-actions">${actionsHtml}</div>` : ''}
                </div>
            `;
        }

        async function handleSlotAction(e) {
            const action = e.target.dataset.action;
            const slotId = e.target.dataset.slotId;

            switch (action) {
                case 'register':
                    await registerForSlot(slotId);
                    break;
                case 'cancel':
                    await cancelRegistration(slotId);
                    break;
                case 'join-waiting':
                    await joinWaitingList(slotId);
                    break;
                case 'leave-waiting':
                    await leaveWaitingList(slotId);
                    break;
            }
        }

        async function registerForSlot(slotId) {
            // Use fresh API data from presenterData instead of localStorage
            const supervisorEmail = presenterData?.supervisorEmail;
            const supervisorName = presenterData?.supervisorName;

            // Check if supervisor info exists
            if (!supervisorEmail) {
                Utils.showToast('Please set up your supervisor information in Presentation Details first.', 'error');
                return;
            }

            Utils.showLoading();
            try {
                // API expects: topic, seminarAbstract, supervisorName, supervisorEmail
                // Username comes from URL path, not body
                await API.registerForSlot(username, slotId, {
                    supervisorEmail: supervisorEmail,
                    supervisorName: supervisorName
                });
                Utils.showToast('Registration submitted! Awaiting supervisor approval.', 'success');
                await loadSlots();
            } catch (error) {
                Utils.showToast('Registration failed: ' + error.message, 'error');
            } finally {
                Utils.hideLoading();
            }
        }

        async function cancelRegistration(slotId) {
            if (!confirm('Are you sure you want to cancel your registration?')) return;

            Utils.showLoading();
            try {
                await API.cancelRegistration(username, slotId);
                Utils.showToast('Registration cancelled.', 'success');
                await loadSlots();
            } catch (error) {
                Utils.showToast('Failed to cancel: ' + error.message, 'error');
            } finally {
                Utils.hideLoading();
            }
        }

        async function joinWaitingList(slotId) {
            Utils.showLoading();
            try {
                // Use fresh API data from presenterData instead of localStorage
                await API.joinWaitingList(slotId, {
                    username: username,  // API expects "username" not "presenterUsername"
                    degree: presenterData?.degree
                });
                Utils.showToast('Added to waiting list!', 'success');
                await loadSlots();
            } catch (error) {
                Utils.showToast('Failed to join waiting list: ' + error.message, 'error');
            } finally {
                Utils.hideLoading();
            }
        }

        async function leaveWaitingList(slotId) {
            if (!confirm('Are you sure you want to leave the waiting list?')) return;

            Utils.showLoading();
            try {
                await API.leaveWaitingList(slotId, username);
                Utils.showToast('Removed from waiting list.', 'success');
                await loadSlots();
            } catch (error) {
                Utils.showToast('Failed to leave waiting list: ' + error.message, 'error');
            } finally {
                Utils.hideLoading();
            }
        }
    </script>
</body>
</html>
