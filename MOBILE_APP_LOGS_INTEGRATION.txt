MOBILE APP LOGS INTEGRATION GUIDE
==================================

OVERVIEW:
---------
This guide shows how to integrate the SemScan API logging system into your mobile app
(Android/iOS) to send logs to the server.

API ENDPOINT:
------------
POST http://your-server:8080/api/v1/logs
Headers: x-api-key: presenter-001-api-key-12345
Content-Type: application/json

ANDROID IMPLEMENTATION:
======================

1. Add to your Android app's build.gradle:
------------------------------------------
implementation 'com.squareup.retrofit2:retrofit:2.9.0'
implementation 'com.squareup.retrofit2:converter-gson:2.9.0'
implementation 'com.squareup.okhttp3:logging-interceptor:4.9.3'

2. Create LogEntry class:
-------------------------
public class LogEntry {
    private Long timestamp;
    private String level;
    private String tag;
    private String message;
    private String userId;
    private String userRole;
    private String deviceInfo;
    private String appVersion;
    private String stackTrace;
    private String exceptionType;
    
    // Constructors, getters, setters...
}

3. Create LogRequest class:
---------------------------
public class LogRequest {
    private List<LogEntry> logs;
    
    public LogRequest(List<LogEntry> logs) {
        this.logs = logs;
    }
    // getters, setters...
}

4. Create API Interface:
------------------------
public interface SemScanApiService {
    @POST("api/v1/logs")
    Call<LogResponse> sendLogs(@Header("x-api-key") String apiKey, 
                               @Body LogRequest request);
}

5. Create Logging Service:
--------------------------
public class AppLoggingService {
    private static final String API_KEY = "presenter-001-api-key-12345";
    private static final String BASE_URL = "http://your-server:8080/";
    
    private SemScanApiService apiService;
    private List<LogEntry> pendingLogs = new ArrayList<>();
    
    public void log(String level, String tag, String message) {
        LogEntry logEntry = new LogEntry();
        logEntry.setTimestamp(System.currentTimeMillis());
        logEntry.setLevel(level);
        logEntry.setTag(tag);
        logEntry.setMessage(message);
        logEntry.setUserId(getCurrentUserId());
        logEntry.setUserRole("STUDENT"); // or "PRESENTER"
        logEntry.setDeviceInfo(getDeviceInfo());
        logEntry.setAppVersion(getAppVersion());
        
        pendingLogs.add(logEntry);
        
        // Send logs in batches (every 10 logs or every 30 seconds)
        if (pendingLogs.size() >= 10) {
            sendLogsToServer();
        }
    }
    
    public void logError(String tag, String message, Exception exception) {
        LogEntry logEntry = new LogEntry();
        logEntry.setTimestamp(System.currentTimeMillis());
        logEntry.setLevel("ERROR");
        logEntry.setTag(tag);
        logEntry.setMessage(message);
        logEntry.setUserId(getCurrentUserId());
        logEntry.setUserRole("STUDENT");
        logEntry.setDeviceInfo(getDeviceInfo());
        logEntry.setAppVersion(getAppVersion());
        logEntry.setStackTrace(getStackTrace(exception));
        logEntry.setExceptionType(exception.getClass().getSimpleName());
        
        pendingLogs.add(logEntry);
        sendLogsToServer(); // Send errors immediately
    }
    
    private void sendLogsToServer() {
        if (pendingLogs.isEmpty()) return;
        
        LogRequest request = new LogRequest(new ArrayList<>(pendingLogs));
        
        apiService.sendLogs(API_KEY, request).enqueue(new Callback<LogResponse>() {
            @Override
            public void onResponse(Call<LogResponse> call, Response<LogResponse> response) {
                if (response.isSuccessful()) {
                    pendingLogs.clear();
                    Log.d("AppLogging", "Logs sent successfully");
                } else {
                    Log.e("AppLogging", "Failed to send logs: " + response.code());
                }
            }
            
            @Override
            public void onFailure(Call<LogResponse> call, Throwable t) {
                Log.e("AppLogging", "Network error sending logs", t);
            }
        });
    }
}

6. Usage in your Android app:
-----------------------------
// Initialize the logging service
AppLoggingService logger = new AppLoggingService();

// Log different types of events
logger.log("INFO", "UserLogin", "User logged in successfully");
logger.log("DEBUG", "QRScan", "QR code scanned: " + qrCode);
logger.log("WARN", "Network", "Slow network connection detected");

// Log errors
try {
    // Some risky operation
} catch (Exception e) {
    logger.logError("Payment", "Payment processing failed", e);
}

iOS IMPLEMENTATION:
==================

1. Create LogEntry struct:
--------------------------
struct LogEntry: Codable {
    let timestamp: Int64
    let level: String
    let tag: String
    let message: String
    let userId: String?
    let userRole: String?
    let deviceInfo: String?
    let appVersion: String?
    let stackTrace: String?
    let exceptionType: String?
}

2. Create LogRequest struct:
----------------------------
struct LogRequest: Codable {
    let logs: [LogEntry]
}

3. Create Logging Service:
--------------------------
class AppLoggingService {
    private let apiKey = "presenter-001-api-key-12345"
    private let baseURL = "http://your-server:8080/"
    private var pendingLogs: [LogEntry] = []
    
    func log(level: String, tag: String, message: String) {
        let logEntry = LogEntry(
            timestamp: Int64(Date().timeIntervalSince1970 * 1000),
            level: level,
            tag: tag,
            message: message,
            userId: getCurrentUserId(),
            userRole: "STUDENT",
            deviceInfo: getDeviceInfo(),
            appVersion: getAppVersion(),
            stackTrace: nil,
            exceptionType: nil
        )
        
        pendingLogs.append(logEntry)
        
        if pendingLogs.count >= 10 {
            sendLogsToServer()
        }
    }
    
    func logError(tag: String, message: String, error: Error) {
        let logEntry = LogEntry(
            timestamp: Int64(Date().timeIntervalSince1970 * 1000),
            level: "ERROR",
            tag: tag,
            message: message,
            userId: getCurrentUserId(),
            userRole: "STUDENT",
            deviceInfo: getDeviceInfo(),
            appVersion: getAppVersion(),
            stackTrace: error.localizedDescription,
            exceptionType: String(describing: type(of: error))
        )
        
        pendingLogs.append(logEntry)
        sendLogsToServer() // Send errors immediately
    }
    
    private func sendLogsToServer() {
        guard !pendingLogs.isEmpty else { return }
        
        let request = LogRequest(logs: pendingLogs)
        
        // Use URLSession or Alamofire to send the request
        // Implementation depends on your networking library
    }
}

SAMPLE JSON REQUEST:
===================
{
  "logs": [
    {
      "timestamp": 1697784000000,
      "level": "INFO",
      "tag": "UserLogin",
      "message": "User logged in successfully",
      "userId": "student-001",
      "userRole": "STUDENT",
      "deviceInfo": "Android 13 - Samsung SM-G991B",
      "appVersion": "1.0.0",
      "stackTrace": null,
      "exceptionType": null
    },
    {
      "timestamp": 1697784001000,
      "level": "ERROR",
      "tag": "Payment",
      "message": "Payment processing failed",
      "userId": "student-001",
      "userRole": "STUDENT",
      "deviceInfo": "Android 13 - Samsung SM-G991B",
      "appVersion": "1.0.0",
      "stackTrace": "java.lang.Exception: Network timeout...",
      "exceptionType": "java.net.SocketTimeoutException"
    }
  ]
}

EXPECTED RESPONSE:
=================
{
  "success": true,
  "message": "Logs processed successfully",
  "processedCount": 2
}

BEST PRACTICES:
==============
1. Send logs in batches (10-20 logs at a time)
2. Send ERROR logs immediately
3. Include device information for debugging
4. Use meaningful tags and messages
5. Handle network failures gracefully
6. Don't block the UI thread for logging

ERROR HANDLING:
===============
- Network errors: Retry with exponential backoff
- Server errors: Log locally and retry later
- Invalid API key: Check configuration
- Rate limiting: Implement backoff strategy

TESTING:
========
Use the test script (test_logs_endpoint.ps1) to verify your mobile app
integration is working correctly.

Generated: $(Get-Date)
